Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\n\nDIS_WIDTH = 600\nDIS_HEIGHT = 600\nGREEN = \"#32CD32\"\nSIZE = 20\nSPEED = 2\nFPS = 30\n\npygame.init()\n\ndis = pygame.display.set_mode((DIS_WIDTH, DIS_HEIGHT))\npygame.display.set_caption(\"Snake\")\n\nprogramIcon = pygame.image.load(\"icon.png\")\npygame.display.set_icon(programIcon)\n\nIMAGE = pygame.image.load(\"icon.png\").convert()  # or .convert_alpha()\nIMAGE = pygame.transform.scale(IMAGE, (SIZE, SIZE))\n\nclock = pygame.time.Clock()\n\n\nclass Velocity:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Position:\n    def __init__(self, x, y, width):\n        self.x = x\n        self.y = y\n        self.width = width\n        self.rect = None\n\n    def draw(self):\n        self.rect = pygame.draw.rect(\n            dis, GREEN, [self.x, self.y, self.width, self.width]\n        )\n\n    def paint_head(self):\n        dis.blit(IMAGE, self.rect)\n\n\nclass Snake:\n    def __init__(self, x_pos, y_pos):\n        self.counter = 0\n        self.length = 4\n        self.blocks = [\n            Position(x_pos - i * SIZE, y_pos, SIZE) for i in range(self.length)\n        ]\n        self.vel = Velocity(SPEED, 0)\n        self.block_vel = [Velocity(SPEED, 0) for i in range(self.length)]\n\n    def draw(self):\n        corners = self.find_corner()\n        for corner in corners:\n            pygame.draw.rect(dis, GREEN, [corner[0], corner[1], SIZE, SIZE])\n        for i in range(len(self.blocks)):\n            self.blocks[i].draw()\n        self.blocks[0].paint_head()\n\n    def find_corner(self):\n        corner_pos = set(())\n        for i in range(1, len(self.blocks)):\n            vec1 = [\n                1 if self.block_vel[i - 1].x == 0 else 0,\n                1 if self.block_vel[i - 1].y == 0 else 0,\n            ]\n            vec2 = [\n                1 if self.block_vel[i].x == 0 else 0,\n                1 if self.block_vel[i].y == 0 else 0,\n            ]\n            pos = (\n                vec1[0] * self.blocks[i - 1].x + vec2[0] * self.blocks[i].x,\n                vec1[1] * self.blocks[i - 1].y + vec2[1] * self.blocks[i].y,\n            )\n            if 0 not in pos:\n                corner_pos.add(pos)\n        return corner_pos\n\n    def keys(self, event):\n        if event.key == pygame.K_LEFT and self.vel.x == 0:\n            self.vel.x = -SPEED\n            self.vel.y = 0\n        elif event.key == pygame.K_RIGHT and self.vel.x == 0:\n            self.vel.x = SPEED\n            self.vel.y = 0\n        elif event.key == pygame.K_UP and self.vel.y == 0:\n            self.vel.x = 0\n            self.vel.y = -SPEED\n        elif event.key == pygame.K_DOWN and self.vel.y == 0:\n            self.vel.x = 0\n            self.vel.y = SPEED\n\n        # cheat until apples are implemented\n        elif event.key == pygame.K_SPACE:\n            self.grow()\n\n    def move(self):\n        # counter until block has to move\n        self.counter += 1\n        if self.counter >= SIZE / SPEED:\n            self.block_vel.pop(-1)\n            self.block_vel = [Velocity(self.vel.x, self.vel.y)] + self.block_vel\n            self.counter = 0\n\n        for i in range(self.length):\n            self.blocks[i].x += self.block_vel[i].x\n            self.blocks[i].y += self.block_vel[i].y\n\n            if self.blocks[i].x >= DIS_WIDTH and self.block_vel[i].x > 0:\n                self.blocks[i].x = -SIZE\n            elif self.blocks[i].y >= DIS_HEIGHT and self.block_vel[i].y > 0:\n                self.blocks[i].y = -SIZE\n            elif self.blocks[i].x <= 0 and self.block_vel[i].x < 0:\n                self.blocks[i].x = DIS_WIDTH\n            elif self.blocks[i].y <= 0 and self.block_vel[i].y < 0:\n                self.blocks[i].y = DIS_HEIGHT\n\n        clock.tick(FPS)\n\n    def grow(self):\n        self.length += 1\n        self.blocks.append(\n            Position(\n                self.blocks[-1].x - self.block_vel[-1].x / SPEED * SIZE,\n                self.blocks[-1].y - self.block_vel[-1].y / SPEED * SIZE,\n                SIZE,\n            )\n        )\n        self.block_vel.append(Velocity(self.block_vel[-1].x, self.block_vel[-1].y))\n\n    def intersect(self):\n        c = 0\n        for i in range (3, self.length):        ##We check if the head connects with the body. We check the intersection after the third block because when the snake turns, the second and third block touch the first one\n            if self.blocks[0].x < self.blocks[i].x + SIZE and self.blocks[0].x > self.blocks[i].x - SIZE and self.blocks[0].y < self.blocks[i].y + SIZE and self.blocks[0].y > self.blocks[i].y - SIZE:\n                c += 1\n        if self.blocks[0].x > DIS_WIDTH or self.blocks[0].x < 0 or self.blocks[0].y > DIS_HEIGHT or self.blocks[0].y < 0:\n            c += 1\n        return c == 0\n\ndef game_loop(time, counter):\n    # time will later be used for score\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            return True\n        if event.type == pygame.KEYDOWN and counter > FPS / 5:\n            player.keys(event)\n            counter = 0\n    player.move()\n    counter += 1\n\n    dis.fill(\"#FFFFFF\")\n    player.draw()\n    pygame.display.update()\n    return False, counter\n\n\ngame_over = False\nplayer = Snake(40, 40)\ntime = 0\ncount = 0\nwhile not game_over:\n    game_over, count = game_loop(time, count)\n    time += 1\n    if Snake.intersect() is False:\n        pygame.quit()\n        quit()\n\npygame.quit()\nquit()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 42616eb24f71d4f4773a977a151afb326de72965)
+++ b/main.py	(date 1670849861935)
@@ -165,7 +165,7 @@
 while not game_over:
     game_over, count = game_loop(time, count)
     time += 1
-    if Snake.intersect() is False:
+    if player.intersect() is False:
         pygame.quit()
         quit()
 
